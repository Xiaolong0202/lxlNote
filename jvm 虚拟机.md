# jvm 虚拟机



是基于栈的指令集架构

![image-20230714233121137](D:\lxlNote\mdPic\jvm 虚拟机\image-20230714233121137.png)

![image-20230714233503478](D:\lxlNote\mdPic\jvm 虚拟机\image-20230714233503478.png)

```
查看详情信息
javap -v Main.class
```

局部变量表（this关键字也在其中，指令就是操纵这些局部变量）：

![image-20230714234843124](D:\lxlNote\mdPic\jvm 虚拟机\image-20230714234843124.png)

JVM运行字节码时，所有的操作基本都是围绕两种数据结构，一种是堆栈（本质是栈结构），还有一种是队列，如果JVM执行某条指令时，该指令需要对数据进行操作，那么被操作的数据在指令执行前，必须要压到堆栈上，JVM会自动将栈顶数据作为操作数。如果堆栈上的数据需要暂时保存起来时，那么它就会被存储到局部变量队列上。

实际上我们发现，JVM执行的命令基本都是入栈出栈等，而且大部分指令都是没有操作数的，传统的汇编指令有一操作数、二操作数甚至三操作数的指令，Java相比C编译出来的汇编指令，执行起来会更加复杂，实现某个功能的指令条数也会更多，所以Java的执行效率实际上是不如C/C++的，虽然能够很方便地实现跨平台，但是性能上大打折扣，所以在性能要求比较苛刻的Android上，采用的是定制版的JVM，并且是基于寄存器的指令集架构。此外，在某些情况下，我们还可以使用JNI机制来通过Java调用C/C++编写的程序以提升性能（也就是本地方法，使用到native关键字）

`iadd`是Java字节码指令之一，用于将栈顶两个整数相加，并将结果存储回栈顶。

`iconst_1`和`ipush`都是Java字节码指令，用于将整数值推送到操作数栈上

## JVM历史

在1996，Java1.0面世时，第一款商用虚拟机Sun Classic VM开始了它的使命，这款虚拟机提供了一个Java解释器，也就是将我们的class文件进行读取，最后像上面一样得到一条一条的命令，JVM再将指令依次执行。虽然这样的运行方式非常的简单易懂，但是它的效率实际上是很低的，就像你耳机里一边在放六级听力，你必须同时记在脑海里面然后等着问问题，再去选择问题的答案一样，更重要的是同样的代码每次都需要重新翻译再执行。

这个时候我们就需要更加高效的方式来运行Java程序，随着后面的发展，现在大多数的主流的JVM都包含即时**编译器**。JVM会根据当前代码的进行判断，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler）

![image-20230715003115194](D:\lxlNote\mdPic\jvm 虚拟机\image-20230715003115194.png)

在JDK1.4时，Sun Classic VM完全退出了历史舞台，取而代之的是至今都在使用的HotSpot VM，它是目前使用最广泛的虚拟机，拥有上面所说的热点代码探测技术、准确式内存管理（虚拟机可以知道内存中某个位置的数据具体是什么类型）等技术.



启动的流程

![image-20230715011346568](D:\lxlNote\mdPic\jvm 虚拟机\image-20230715011346568.png)

使用JNI (java native interface)调用c语言，

```
//使用c语言标记，交给c语言来实现
public static native int sum(int a,int b);
```

先使用c语言编写好并生成动态链接库，并使用System.load()引入动态链接库就可以使用了c语言编写好的逻辑了