## mq的使用场景

- 异步
- 解耦  比如跨语言调用  可以 多个消费者实现  
- 削峰

缺点：

-  可用性
- 系统复杂度
- 数据一致性

## RocketMQ

功能齐全

高吞吐  高并发  高可用 

开源版不如云上商业版本  生态不如 rabbitMQ  kafka

一个JVM进程当中只能有一个事务处理器

一个JVM进程当中一个消费者组只能有一个监听器

## 哪些环节会有消息的丢失

1. 生产者发送消息会丢失

   **事务消息保证发送消息与本地事务是原子性的**、发送确认，**rocketMQ发送异步消息课实现回调函数**，还有同步消息也可以获取结果,发送单向消息就不需要关心消息的结果

2. 主从同步会丢失

   普通集群中主从同步有两种方式：同步同步、异步同步（效率更高但是消息可能会丢失）

   Dleger集群 两阶段  大多数结点commit之后再确认发送

3. 持久化可能会丢失

   同步刷盘  、异步刷盘

4. 消费者消费会丢失

   offset

   同步消费，默认的，就是当消息发送过来当事务处理成功就返回确认，如果本地抛出异常或执行出错就会重发

   异步消费  消费者接收到了就返回

## 如何保证顺序消费的

```java
rocketMqTemplate.sendOrderly()//发送端
@RocketMQMessageListener(consumeMode = ConsumeMode.ORDERLY)//接收端
```

### 原理：

##### 顺序混乱的原因：
​				一个topic里面有多个queue,消息被分散在多个队列当中，消费者消费的时候就不一定能够保证顺序                

​				多个线程去竞争一个队列里面的东西					

##### 服务端： 在选择队列的时候将同一组的需要保证顺序的顺序消息都放在一个queue里面，

##### 消费者端： 在消费的时候对队列进行加锁，这样就不会有别的线程去竞争，就可以导致该队列的消息只能被这个线程消费，就可以保证消息的按序消费

## 如何保证高效的读写

通过零拷贝来实现的

mmap

sendFile

## 消费者与队列的关系

在**集群模式**当中以**消费组为维度**，**一个消费者能分配多个队列，但一个队列只会分配给一个消费者**。故一个topic的队列数量直接决定了其支持的消费者的最大数，**如果topic的队列数量小于消费者的数量，那部分消费者将无法消费消息**。

**广播模式**：一个消费组内的每一个消费者都会消费topic中的所有消息，即**topic 中的所有队列都会分配给消费组内的每一个消费者**，其主要使用场景：**刷新本地缓存**。

