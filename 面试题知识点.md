## Redis

![image-20231115214504285](mdPic/面试题知识点/image-20231115214504285.png)

延时队列使用zset

消息队列使用list

![image-20231115214554996](mdPic/面试题知识点/image-20231115214554996.png)

**缓存穿透：** 每次都会查询一个不存在的数据，导致每次请求都去查询数据库，

解决方案：

1.**缓存空数据**2.**使用布隆过滤器，**在使用缓冲之前先查询布隆数据库，拦截布隆过滤器（
可以使用位图bitmap实现）,将key进行多次hash，根据多次hash将对应的数据bit变为1，查询数据的时候就可以使用hash函数判断是否存在（可能存在误判，即某个不存在的也可被误判为存在）

**缓存击穿** 某一个key刚好过期大量的请求进来将DB压垮

两种解决方案：互斥锁（数据的一致性），与逻辑过期（可用性）

![image-20231115215804896](mdPic/面试题知识点/image-20231115215804896.png)

**缓存雪崩** 指集体失效，比如许多热点key在同一时间过期（可以给每个key设置随机的过期时间），**redis宕机**，可以搭建redis的集群来预防,哨兵集群模式

添加多级缓存

添加限流

**双写一致：**保证数据库与redis缓存的一致性

措施:

延时双删(不能保证数据强一致性),延时是想让主节点数据库数据扩散至从结点:

![image-20231116203045509](mdPic/面试题知识点/image-20231116203045509.png)

**保证强一致性的方法，**对一个数据的读或写都添加分布式锁,但是性能会下降

对于读多写少的场景，我们可以使用共享锁与排他锁结合使用，

![image-20231116203848247](mdPic/面试题知识点/image-20231116203848247.png)

**保证最终一致性**，可以使用消息队列,先修改数据库，使用异步通知的方式更新缓存保证最终一致性

![image-20231116204153597](mdPic/面试题知识点/image-20231116204153597.png)

**redis的持久化**

**RDB**:就是将数据以文件的方式存储至磁盘当中,数据快照

可以使用save(主进程)与bgsave(子进程)命令执行RDB

可以使用redisconfig来配置rdb触发机制

![image-20231116211012782](mdPic/面试题知识点/image-20231116211012782.png)

![image-20231116211431787](mdPic/面试题知识点/image-20231116211431787.png)

**AOF:**记录命令的日志

在配置文件中配置appendonly打开

![image-20231116211538098](mdPic/面试题知识点/image-20231116211538098.png)

几种频率:

![image-20231116211608581](mdPic/面试题知识点/image-20231116211608581.png)

为了防止命令的冗余，可以使用bgrewriteaof命令，执行aof文件的重写减少aof文件大小

![image-20231116211757952](mdPic/面试题知识点/image-20231116211757952.png)

百分比与体积两种重写的阈值

AOF与RDB对比：

![image-20231116211854147](mdPic/面试题知识点/image-20231116211854147.png)

**redis key的过期后的删除策略:**

1.惰性删除，在过期之后还在内存当中不去管他，当再次使用到他的时候在对他进行检测，如果过期了的话就删除,(对CPU有好，但是对内存不友好比较浪费)

2.定期删除，每隔一定的时间，就会遍历定量的key,删除里面过期的key,

定期删除的时候有两种模式：

![image-20231116212617433](mdPic/面试题知识点/image-20231116212617433.png)

定期删除执行时间少的原因是尽量的不占用CPU资源

![image-20231116212737404](mdPic/面试题知识点/image-20231116212737404.png)



**redis的淘汰策略:**

当redis内存不够用的时候需要对redis中的key进行淘汰,八种淘汰策略

![image-20231116214008631](mdPic/面试题知识点/image-20231116214008631.png)

redis分布式锁，使用set nx  ex命令实现,可以使用看门狗机制使用守护线程来进行锁的续期,每隔releaseTime/3的时间续期，redssion实现的分布式锁是可重入锁

为了保证主从数据的一致性，也就是怕主节点突然宕机，redission还实现了红锁,在多个节点上创建锁(实现起来特别复杂)：

![image-20231116220250264](mdPic/面试题知识点/image-20231116220250264.png)

红锁实现复杂成本高，如果非要保证强一致性，就要使用zookeeper（CP），redis是(AP)

**Redis集群的方案：**

**1.主从复制**

主节点一般实现写操作，从节点一般实现读操作，主节点写入数据的时候需要同步给从节点

**同步的情况**

1.主从全量同步

![image-20231116221102627](mdPic/面试题知识点/image-20231116221102627.png)

![image-20231116221418159](mdPic/面试题知识点/image-20231116221418159.png)

**哨兵机制**

监控主从结点的故障，

故障恢复，如果主节点宕机了，会推选从节点充当新的从节点，

通知，推举新的主节点，故障转移的时候会通知Redis客户端

![image-20231116222835561](mdPic/面试题知识点/image-20231116222835561.png)

![image-20231116223003718](mdPic/面试题知识点/image-20231116223003718.png)

**脑裂问题：**

因为网络故障问题，产生了两个主节点，客户端还在往原来的主节点中写入数据，等到网络恢复的时候，redis集群会将之前的主节点当做salve从节点,数据清空，导致数据丢失

![image-20231116223627717](mdPic/面试题知识点/image-20231116223627717.png)

解决方案：通过配置来使得被分离的老的主节点拒绝客户端的请求

![image-20231116223430715](mdPic/面试题知识点/image-20231116223430715.png)

**分片集群** 可以支持海量数据，每个结点master都存储不同的数据：

![image-20231116230638676](mdPic/面试题知识点/image-20231116230638676.png)

可以使用哈希槽的方法来实现决定一个key对应的位置应该放在哪里

**Redis是单线程的为什么这么快**

- c语言编写的,他是内存数据库，他可以直接操纵内存，当然快
- 他是单线程的，不需要进行上下文的切换,切换可竞争条件
- 它的网络IO是非阻塞IO，使用了IO多路复用模型

Redis是纯内存模型，所以说他的性能瓶颈其实是网络IO，I/O多路复用就是为了实现高效的网络请求

**传统io模型降低效率的两个点：**

-  用户空间与内核空间频繁的数据拷贝就降低了效率，
- 还有是用户缓冲区一直等待内核缓冲区的数据也会降低效率

![image-20231117145236224](mdPic/面试题知识点/image-20231117145236224.png)

**阻塞IO**

![image-20231117145420090](mdPic/面试题知识点/image-20231117145420090.png)

**非阻塞IO**

![image-20231117145607981](mdPic/面试题知识点/image-20231117145607981.png)

**IO多路复用**

![image-20231117145824175](mdPic/面试题知识点/image-20231117145824175.png)

**Linux实现IO多路复用的三种方式**

- select、poll 这两种方式只会通知用户进程有socket的资源已经准备好了，但是不会告诉用户进程是哪一个socket资源准备好了，需要用户进程去进行轮询，
- epoll ,在通知用户进程socket进程准备好的时候，会顺便告诉用户进程是哪一个用户进程准备好了,就可以直接将socket放入用户空间

**Redis的网络模型,6.0之后引入了多线程**

多线程主要是对IO部分添加了多线程的处理

IO复用+事件派发

![image-20231117152808545](mdPic/面试题知识点/image-20231117152808545.png)

# MYSQL

mysql定位慢查询

可以使用sql的日志

![image-20231117161509430](mdPic/面试题知识点/image-20231117161509430.png)

![image-20231117162547818](mdPic/面试题知识点/image-20231117162547818.png)

使用explain对sql执行计划进行分析

![image-20231117163057736](mdPic/面试题知识点/image-20231117163057736.png) 

![image-20231117163357429](mdPic/面试题知识点/image-20231117163357429.png)

**索引的概念：**

​	索引(index) 是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构(B+树)，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构， 上实现高级查找算法，这种数据结构就是索引。对查找的字段进行排序

**索引的底层数据结构**

使用B+树

优点

- 使用的是矮胖树，阶层更低，路径更短
- 磁盘读写的代价更低，非叶子结点只存储指针，只有叶子结点是存储的数据
- B+树的叶子结是一个双向链表，更利于扫库和查询范围

**索引的分类**

- 聚集索引，  一般是针对于主键的索引。聚集索引一张表当中一般只存在一个，该索引结构中存放数据的部分存储着整行的所有字段的数据 ,数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个

  一般会将给一个表的主键创建索引，如果一个表中没有主键，就会给这个表当中的唯一键创建聚集索引，如果也没有唯一键，数据库会给表中的没有每一行创建一个rowid，给这个rowid创建聚集索引

- 二级索引、非聚集索引、普通索引，该索引，一张表当中可以创建多个，但是该种索引存放数据的部分，存放的是该数据的主键，数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个

**回表**

> 通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表

**覆盖索引 ** 覆盖索引是指查询使用了索引，返回的列，必须在索引中全部能够找到，不用回表的就是覆盖索引。

使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高
如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select*

使用覆盖索引解决超大问题：

覆盖索引子查询

![image-20231117174803721](mdPic/面试题知识点/image-20231117174803721.png)

**索引创建的原则：**

+ 对于数据量大的表创建索引，增加用户体验，如数据量大于十万
+ 对于经常作为where 、order by、group by 操作的字段，创建索引
+ 尽量选择区分度较高的字段创建索引，这样效率更高
+ 对于字符创类型的字段如果长度较长可以针对字段的特点创建前缀索引
+ 要尽量使用联合索引，使用联合索引的时候很多时候可以覆盖索引，可以节省空间，避免回表，提高查询的效率
+ 控制索引的数量，索引不是越多越好