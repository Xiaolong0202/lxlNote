## Redis

![image-20231115214504285](mdPic/面试题知识点/image-20231115214504285.png)

延时队列使用zset

消息队列使用list

![image-20231115214554996](mdPic/面试题知识点/image-20231115214554996.png)

**缓存穿透：** 每次都会查询一个不存在的数据，导致每次请求都去查询数据库，

解决方案：

1.**缓存空数据**2.**使用布隆过滤器，**在使用缓冲之前先查询布隆数据库，拦截布隆过滤器（
可以使用位图bitmap实现）,将key进行多次hash，根据多次hash将对应的数据bit变为1，查询数据的时候就可以使用hash函数判断是否存在（可能存在误判，即某个不存在的也可被误判为存在）

**缓存击穿** 某一个key刚好过期大量的请求进来将DB压垮

两种解决方案：互斥锁（数据的一致性），与逻辑过期（可用性）

![image-20231115215804896](mdPic/面试题知识点/image-20231115215804896.png)

**缓存雪崩** 指集体失效，比如许多热点key在同一时间过期（可以给每个key设置随机的过期时间），**redis宕机**，可以搭建redis的集群来预防,哨兵集群模式

添加多级缓存

添加限流

**双写一致：**保证数据库与redis缓存的一致性

措施:

延时双删(不能保证数据强一致性),延时是想让主节点数据库数据扩散至从结点:

![image-20231116203045509](mdPic/面试题知识点/image-20231116203045509.png)

**保证强一致性的方法，**对一个数据的读或写都添加分布式锁,但是性能会下降

对于读多写少的场景，我们可以使用共享锁与排他锁结合使用，

![image-20231116203848247](mdPic/面试题知识点/image-20231116203848247.png)

**保证最终一致性**，可以使用消息队列,先修改数据库，使用异步通知的方式更新缓存保证最终一致性

![image-20231116204153597](mdPic/面试题知识点/image-20231116204153597.png)

**redis的持久化**

**RDB**:就是将数据以文件的方式存储至磁盘当中,数据快照

可以使用save(主进程)与bgsave(子进程)命令执行RDB

可以使用redisconfig来配置rdb触发机制

![image-20231116211012782](mdPic/面试题知识点/image-20231116211012782.png)

![image-20231116211431787](mdPic/面试题知识点/image-20231116211431787.png)

**AOF:**记录命令的日志

在配置文件中配置appendonly打开

![image-20231116211538098](mdPic/面试题知识点/image-20231116211538098.png)

几种频率:

![image-20231116211608581](mdPic/面试题知识点/image-20231116211608581.png)

为了防止命令的冗余，可以使用bgrewriteaof命令，执行aof文件的重写减少aof文件大小

![image-20231116211757952](mdPic/面试题知识点/image-20231116211757952.png)

百分比与体积两种重写的阈值

AOF与RDB对比：

![image-20231116211854147](mdPic/面试题知识点/image-20231116211854147.png)

**redis key的过期后的删除策略:**

1.惰性删除，在过期之后还在内存当中不去管他，当再次使用到他的时候在对他进行检测，如果过期了的话就删除,(对CPU有好，但是对内存不友好比较浪费)

2.定期删除，每隔一定的时间，就会遍历定量的key,删除里面过期的key,

定期删除的时候有两种模式：

![image-20231116212617433](mdPic/面试题知识点/image-20231116212617433.png)

定期删除执行时间少的原因是尽量的不占用CPU资源

![image-20231116212737404](mdPic/面试题知识点/image-20231116212737404.png)



**redis的淘汰策略:**

当redis内存不够用的时候需要对redis中的key进行淘汰,八种淘汰策略

![image-20231116214008631](mdPic/面试题知识点/image-20231116214008631.png)

redis分布式锁，使用set nx  ex命令实现,可以使用看门狗机制使用守护线程来进行锁的续期,每隔releaseTime/3的时间续期，redssion实现的分布式锁是可重入锁

为了保证主从数据的一致性，也就是怕主节点突然宕机，redission还实现了红锁,在多个节点上创建锁(实现起来特别复杂)：

![image-20231116220250264](mdPic/面试题知识点/image-20231116220250264.png)

红锁实现复杂成本高，如果非要保证强一致性，就要使用zookeeper（CP），redis是(AP)

**Redis集群的方案：**

**1.主从复制**

主节点一般实现写操作，从节点一般实现读操作，主节点写入数据的时候需要同步给从节点

**同步的情况**

1.主从全量同步

![image-20231116221102627](mdPic/面试题知识点/image-20231116221102627.png)

![image-20231116221418159](mdPic/面试题知识点/image-20231116221418159.png)

**哨兵机制**

监控主从结点的故障，

故障恢复，如果主节点宕机了，会推选从节点充当新的从节点，

通知，推举新的主节点，故障转移的时候会通知Redis客户端

![image-20231116222835561](mdPic/面试题知识点/image-20231116222835561.png)

![image-20231116223003718](mdPic/面试题知识点/image-20231116223003718.png)

**脑裂问题：**

因为网络故障问题，产生了两个主节点，客户端还在往原来的主节点中写入数据，等到网络恢复的时候，redis集群会将之前的主节点当做salve从节点,数据清空，导致数据丢失

![image-20231116223627717](mdPic/面试题知识点/image-20231116223627717.png)

解决方案：通过配置来使得被分离的老的主节点拒绝客户端的请求

![image-20231116223430715](mdPic/面试题知识点/image-20231116223430715.png)

**分片集群** 可以支持海量数据，每个结点master都存储不同的数据：

![image-20231116230638676](mdPic/面试题知识点/image-20231116230638676.png)

可以使用哈希槽的方法来实现决定一个key对应的位置应该放在哪里