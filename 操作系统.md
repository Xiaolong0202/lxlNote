## 软中断 与 硬中断

硬中断，一般是由于系统相连的硬件设备触发的，主要是来通知操作系统的变化，比如网卡接收数据包

键盘输入字符

软中断 中断处理是越快越好，但是终端如果处理时间需要太长的话就不行，所以对那些处理时间太长的中断，系统会用一个内核线程来处理剩下的任务,对应软中断，由内核触发中断，用来异步处理上半部未完成的工作

## 微内核与宏内核

**微内核**只实现最基本的功能,  内核架构的内核**只保留最基本的能力**，比如进程调度、虚拟机内存、中断等，把一些应用放到了用户空间，比如驱动程序、文件系统等。   其他功能由不同进程来实现，中央内核调用通信来处理，解耦，可扩展

微内核通信需要花费时间，效率更低

宏内核将所有功能的实现都放入了一块，完成了所有的基础功能  linux 一直坚持宏内核

## 内存

### 虚拟内存：

我们应用程序实际上是不可以操纵真实的**物理内存**的，应用所获取到的内存其实**是虚拟内存**，并且应用误以为这是一段连续的内存，实际上他可能是碎片化的

操作系统为每个进程都分配一组虚拟内存，不同进程之间互不干扰

虚拟内存地址可以通过MMU(内存管理单元) 转换为物理内存地址

操作系统通过**内存分段与内存分页**，来维护物理内存与虚拟内存之间的关系

### 内存分段

将物理地址分成很多的**段**，操作系统会将这些段分配给应用程序，应用程序的**虚拟地址结构**包括：**段选择因子、段内偏移量（也就是相对物理基地址的偏移量）**

段选择因子就包括了**段号**，通过段号，在**段表**中，就可以查到**段的基地址，段的界限**等信息，所以通过段的基地址加上锻内偏移量即可找到正确的物理地址

##### 缺点：

- **内存碎片**  由于段是一块连续的内存空间，所以当很容易出现内存碎片
- **内存交换效率低**  内存交换式，一块较大的连续内存

### 内存分页

分页方案，操作系统，将虚拟内存与物理内存都分成了一个一个等大的内存块，这这些等大的内存块就是**页**，页是**内存分配的最小单元**，所以有可能产生**内存浪费**的情况，但是在内存不够用的情况下，操作系统会将一个应用程序最近没有使用过的页，暂时放在**硬盘的swap区**

操作系统通过**页表**维护 **虚拟页号** 与 物理页号之间的**映射**关系

分页机制下的虚拟地址  包括 **虚拟页号** 与  **页内偏移量**， 操作系统通过页表找到物理页，通过业内偏移量即可找到真实的物理地址

##### 缺页中断：

> 进程访问的虚拟地址在页表当中找不到的时候就会发生缺页中断，此时会由内核分配内存并更新进程的页表

##### 缺点：

每个进程维护一个页表，维护页表的内存占用太过于大

##### 多级页表:

  将单页表**拆分**成**多个页表**，那么一个虚拟地址中就要包含**多个页表页号**，比如**一级页号**，**二级页号**，

层层递进最终找到物理地址，这样子一个一级页表就可以表示更多的空间，然后再去二级页表中找更细的页，由于**二级页表是懒加载的,需要的时候才会被创建**，所以是更节省空间

**但是多级页表之间的转换会耗费时间复杂度**

**TLB**

是一个缓存，虚拟地址查询物理基地址的时候，先去查询缓存，缓存没有命中再去查询

### 段页式内存管理：

就是将分段与分页组合起来，再一个操作系统中使用

内存分配就是，先将**内存中分段**，但是**段中又会分页**

那这样的话，虚拟地址，就包括   **段号、段内页号、页内偏移**

### 分配内存的过程：

先给进程分配**虚拟内存**，当cpu访问该虚拟内存的时候，在页表当中找不到的时候，发生**缺页中断**，去查找空闲的物理内存并进行分配，如果内存不够就会清理内存

先是**异步回收**，就是通过后台进程

如果异步回收更不上了，就会执行阻塞的**直接内存回收**

匿名页 与 文件页 可以进行回收

如果还是不够的话就会**触发OOM,**他会杀死一个**物理内存占用比较高的进程**