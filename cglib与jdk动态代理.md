## JDK 动态代理和 CGLIB（Code Generation Library）代理都是在运行时生成代理对象的技术，但它们有一些关键的区别：

1. **基于接口 vs 基于类：**
   - **JDK 动态代理：** 要求被代理的类必须实现一个或多个接口，代理对象实现了这些接口，因此它仅能代理接口中定义的方法。
   - **CGLIB 代理：** 不要求被代理的类实现接口，它通过继承被代理类来创建代理对象，因此可以代理类中的非 final 方法。
2. **实现方式：**
   - **JDK 动态代理：** 利用 `java.lang.reflect` 包中的 `Proxy` 类和 `InvocationHandler` 接口。通过生成字节码实现接口的方式来创建代理对象。
   - **CGLIB 代理：** 利用字节码生成库，通过生成被代理类的子类来创建代理对象。
3. **性能：**
   - **JDK 动态代理：** 由于是基于接口的代理，它的性能相对较高。但在代理大量方法时，性能可能略低于 CGLIB。
   - **CGLIB 代理：** 由于是基于类的代理，它可以代理类中的所有方法，包括 final 方法。在代理类的方法较多时，CGLIB 可能比 JDK 动态代理性能更好。
4. **被代理类的要求：**
   - **JDK 动态代理：** 被代理类必须实现接口。
   - **CGLIB 代理：** 被代理类不需要实现接口，可以是普通的类。
5. **类加载器：**
   - **JDK 动态代理：** 代理对象由 `Proxy.newProxyInstance` 方法创建，它通过指定的类加载器来加载代理类。
   - **CGLIB 代理：** 代理对象是通过继承被代理类而创建的，因此它的加载器通常是被代理类的类加载器。

## **在Spring AOP中，选择使用CGLIB还是JDK动态代理通常取决于以下两个因素：**

1. **接口的存在：**
   - **如果目标对象实现了接口：** Spring AOP会尝试使用JDK动态代理。在这种情况下，代理对象将实现目标对象所实现的接口，并且方法调用将通过代理对象的接口进行分派。
   - **如果目标对象没有实现接口：** Spring AOP将使用CGLIB来创建代理。CGLIB可以代理没有实现接口的类，并生成目标类的子类作为代理对象。
2. **代理的创建方式：**
   - **如果使用基于接口的代理方式：** JDK动态代理会被使用。这通常涉及到目标对象实现了一个或多个接口，而代理对象将实现这些接口。
   - **如果使用基于类的代理方式：** CGLIB会被使用。当目标对象没有实现接口或者你明确要求使用CGLIB时，Spring会使用CGLIB来创建代理对象。