# MySql  锁

```mysql
select * from performance_schema.data_locks;//查看当前所有的锁
```

## 全局锁

数据库级别的锁



## 表级别锁

### 表锁

- 表共享锁  加了表共享锁，他自己也不能进行 改 、删、写
- 表排他锁

### 元数据锁(meta data lock)

为了防止DDL与DML的冲突

当有活动的事务未提交的时候，不能进行alter 也就是表结构的操作

### 意向锁

防止行锁与表锁的冲突，如果一个表中的行添加了行锁，则不能添加对应表锁，但是肯定不能去每一行去查看有没有添加行锁，所以要给这个表添加一个意向锁，用来判断该表有无添加行锁

- 意向共享锁(SX) 与表读锁 兼容，也就是说有SX，可以添加表读锁，但是与表写锁不兼容
- 意向排他锁 (IX)  与表读锁与表共享锁都不兼容

## 行级锁

### 行锁 / 记录锁    

如果进行操作的时候，涉及到的条件查找操作不通过索引来查找，就会升级为表锁

通过索引来实现的，MYISAM  存储引擎当中并不支持，所以单个记录，在RR （可重复读）与RC（读已提交）

- 共享锁
- 排他锁

![image-20231126011745416](mdPic/MySql锁/image-20231126011745416.png)

### 间隙锁(开区间)

锁定索引的间隙，保证索引记录的间隙不变

**间隙锁可能会产生死锁的问题**，当两个事务都在同一个区间添加了间隙锁，并且都想要对这个区间进行insert操作的时候就会触发死锁问题，因为两个事务都会等待对方事务的资源释放，触发超时，自动回滚某一个事务

- 唯一索引为等值条件查询的时候，给不存在的记录加锁

  比如本来有 id = 3 , id =8

  操纵数据的时候条件 where id = 5,就会给 (3,8)这个区间加锁,不允许对该区间进行操作

- 普通索引 等值查询  会将 索引值为中心，向左第一个比他小的，像右第一个比他大的加锁

### 临键锁 （闭区间）

比如加锁的时候使用范围条件查询就可以添加临键锁

前两者的结合，既能够保证数据不变，也能够保证间隙,RR隔离级别支持

唯一索引、范围查询

# 结构

## 内存：

### Buffer Pool  缓存池

缓存磁盘当中的真实数据，先操作缓冲池中的数据，缓冲池再写入

- 空闲页  free Page 没有被使用过的
-  clean Page  被使用的page 但是没有被修改过
- dirty page 被使用了并且被修改了  buffer pool 中的与磁盘中的不一致

### change Buffer

针对非唯一 二级索引

8.0之后  如果进行DML语句的时候，buffer pool中没有响应的的页，就先将修改操作存入change buffer当中，等到buffer pool中有了再合并

### 自适应Hash索引

Adaptive Hash Index:自适应hash索引，用于优化对Buffer Pool数据的查询。InnoDB存储引擎会监控对表_上各索引页的查询，如果观察到hash索引可以提升速度,则建立hash索引,称之为自适应hash索引

自适应哈希索引，无需人工干预，是系统根据情况自动完成。
参数: adaptive_ hash_ index

### 日志缓冲区

默认16MB, 用于存储要写入到磁盘的日志(undolog、redolog)

## 磁盘：

**File-Per-Table Tablespaces:**每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在
文件系统上的单个数据文件中。

表空间，ibd文件，存放表的结构、数据、索引

**General Tablespaces:通用表空间**，需要通过CREATE TABLESPACE 语法创建通用表空间，在创建表时，可
以指定该表空间。

**undolog 表空间**创建两个默认相同的表空间存放 undlog日志

删除时机：

**当insert的时候**，产生的undo log日志只在回滚时需要,在事务提交后,可被立即删除。
**而update、delete的时候**， 产生的undo log日志不仅在回滚时需要，在快照读时也需要,**不会**立即被删除。

**Temporary Tablespaces:** InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。

**Doublewrite Buffer Files: 双写缓冲区**，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。

**Redo Log:重做日志**，是用来实现事务的持久性。该日志文件由两部分组成:重做日志缓冲(redo log buffer)以及重做日志文件(redo log) ,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中,用于在刷新脏页到磁盘时,发生错误时,进行数据恢复使用。**(会定时清理)**

![image-20231126142241774](mdPic/MySql高级/image-20231126142241774.png)

### 后台线程

![image-20231126142353947](mdPic/MySql高级/image-20231126142353947.png)

# MVCC多版本并发控制

全称Multi-Version Concurrency Control,多版本并发控制。指维护一-个数据的多个版本,使得读写操作没有冲突,快照读为MySQL实现
MVCC提供了-个非阻塞读功能。MVCC的具体实现，还需要依赖于**数据库记录中的三个隐式字段、undo log日志、readView**。

- 当前读，读取的是当前mysql当中的最新的数据
- 快照读  读取的是历史记录可见版本,
  Read Committed:每次select, 都生成一一个快照读。
  Repeatable Read:开启事务后第一个select语句才 是快照读的地方。
  Serializable:快照读会退化为当前读。

## 隐藏字段

**DB_TRX_ID** 最近一次修改、插入操作的事务的ID

**DB_ROLL_PTR** 回滚指针，指向该记录的上一个版本,用于配合undolog指向上一个版本,指向undo log

**DB_ROW_ID** 隐式主键，没有主键或者唯一键的时候生成

## undolog 版本链

当多个日志对应同一条数据进行修改操作的时候，会产生多条undolog 日志,而这多条undolog日志会形成一个链表，链表头部是最新的记录，尾部是最旧的日志，这就是版本链

## ReadView

是快照读SQL执行MVCC提取数据的依据，它用来记录并维护当前活跃事务的id，他有四个核心的字段

- 当前活跃的事务ID的集合
- 事务id集合中最小的id
- 事务id集合中的最大的id
- 事务id集合中的创建者事务 id

## MVCC实现原理

如果是RC 读已提交隔离级别，那么就会在每一次进行快照读的时候都创建一个readView

如果是RR  可重复读，就会在一个事务中第一次对该条记录进行快照读的时候创建ReadView,之后的快照读，都会使用这一个ReadView

快照读的时候会从undolog版本链的头结点的版本开始比对，直到找到第一个符合条件的记录：

**通过undlog 链 找到 一个 在readView 生成之前就提交的记录，或者是读视图创建者记录修改的记录**

比对规则如下：

![image-20231126154532197](mdPic/MySql高级/image-20231126154532197.png)

## 索引下推：

在索引失效的情况下，如果没有索引下推技术的话，会进行多次回表，但是有了索引下推，就可以先通过现有的字段，在索引当中先进行过滤，然后再使用过滤之后的索引进行回表

上面的例子中，提到了like,包括MySQL官网中也只提到了like,但是其实不止有like。因为我认为索引下推其实
是解决索引失效带来的效率低的问题的一种手段。
所以当联合索引中，某个非前导列因为索弓|失效而要进行扫表并回表时，就可以进行索引下推优化了。
如，有a,b联合索引，类型都是varchar,以下SQL也可以用到索引下推:

``` sql
select d fromt 2 where a="ni" and b=1;
```


因为b字段因为类型不匹配导致索引失效了，但是通过下推优化其实是可以减少回表的次数的。

## binlog 与 redolog的日志恢复的区别

binlog 和 redolog 是 MySQL 中两种不同的日志文件。binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用，而 redolog 是 InnoDB 引擎特有的。binlog 是逻辑日志，记录的是数据库操作语句，主要用于人工恢复数据。redo log 是物理日志，记录的是在某个表做了什么修改，用于 MySQL 异常重启时数据恢复，所以恢复速度比 binlog 更快。

## mysql 产生死锁

1)表的死锁
产生原因:
用户A访问表A (锁住了表A)，然后又访问表B;另一个用户B访问表B (锁住了表B)，然后企图访问表A;这时
用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这
就死锁就产生了。

解决方案：只能调整程序的逻辑

2）行级别的死锁

1. 执行没有索引的操作，升级为表级锁，如果执行多个这种事务，就会阻塞
2. 占有多个行，两个行之间想互相占有
3. 同一条sql产生死锁，就是同一条sql如果它需要对多个行加锁，同时进行操作的时候就可能导致死锁，两个线程分别先拿到了其中一个资源，并持有等待

需要调整访问顺序，让线程以固定顺序执行